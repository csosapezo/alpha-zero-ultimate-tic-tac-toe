import jsonfrom keras.models import Sequential, load_modelfrom keras.layers import Densefrom keras.utils import plot_modelimport numpy as npclass NNUltimateLearning:    def __init__(self, filename):        self.values = {}        self.model = load_model(filename)        self.initializeModel()    def initializeModel(self):        self.model = Sequential()        self.model.add(Dense(81, input_dim=81, activation='relu'))        #self.model.add(Dense(81, activation='relu'))        self.model.add(Dense(1, activation='linear', kernel_initializer='glorot_uniform'))        self.model.compile(loss='mean_squared_error', optimizer='adam', metrics=['accuracy'])        plot_model(self.model, to_file='model.png')    def initialModelTraining(self, jsonFile):        # If the neural network model should be seeded from some known state/value pairs        import os        if os.path.isfile(jsonFile):            self.values = json.load(open(jsonFile, 'r'))            self.gameOver()    def resetForNewGame(self):        self.values = {}    def trainModel(self, boardStates, y):        self.model.fit(np.asarray(boardStates), np.asarray(y), verbose=0)    def getPrediction(self, boardState):        return self.model.predict(boardState.reshape((1, 81)))[0]    def getBoardStateValue(self, player, board, boardState):  #TODO: Can batch the inputs to do several predictions at once        predY = self.getPrediction(boardState)[0]        if board.is_win(player):            predY = 1.0        elif board.is_win(-player):            predY = 0.0        elif not board.has_legal_moves():            predY = 0.5        else:            pass        return predY    def learnFromMove(self, player, board, prevBoardState):        curBoardState = board.getBoardState()        curBoardStateValue = self.getBoardStateValue(player, board, curBoardState)        prevBoardStateValue = self.getPrediction(prevBoardState)[0]        self.values[prevBoardState] = prevBoardStateValue + 0.2 * (curBoardStateValue - prevBoardStateValue)    def printValues(self):        pass    def saveLearning(self, filename):        self.model.save(filename)    def loadLearning(self, filename):        self.model = load_model(filename)